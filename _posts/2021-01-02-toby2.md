---
title: Deep Dive in Spring - 2
subtitle: Spring에서의 DI&IoC, PSA
date: 2021-01-02
categories:
  - Spring
tags:
  - Spring
  - Java
---

# Deep dive Spring 2

Spring의 DI(IoC)와 PSA 그리고 인터페이스 추상화, PSA 등의 키워드로 학습

# 객체지향과 Spring

Spring은 Java 기반으로한 프레임웍이라는 점에서 그 철학에는 객체지향의 가치가 매우 많이 녹여져 있다. 즉 Spring 을 잘 깊이 이해하려면 객체지향을 잘 알아야한다는 것이다.

### 1. Spring과 객체지향

자바에서 가장 중요하게 생각하는것은 무엇일까? 내가 SW 설계 과목을 들으면서 몸소 와닿았던 자바의 핵심 가치는 "유지보수가 쉬운 코드"를 항상 추구하고 있다는 것이였다.

이를 위해 '낮은 결합도와 높은 응집도' 그리고 '코드 변경에는 닫혀있고 기능 확장에는 열려있는 코드작성' 등 다양한 원칙들을 고수하고있다. 이런 원칙들을 지킴으로서 객체지향이 궁극적으로 이루고자 하는 목표인 '지속적으로, 그리고 효율적으로 유지 가능한 SW 개발'을 이루어낼 수 있다.

Spring에서는 이런 OOP의 가치를 100% 활용하고있다. 그리고 이런 가치를 활용할 수 있는 Best Case 형태로 추상화하여 기본적인 '틀'의 형태로 제공하고 있다.

### 2. 오브젝트

Spring과 자바 개발자들이 가장 중요시 하는것이 무엇인가? 바로 클래스(오브젝트)이다.

객체지향은 실세계를 가장 잘 반영할 수 있게끔 만들어진 언어이니 만큼 실세계의 대상을 코드로 나타낸 '오브젝트'에 가장 많은 관심을 갖게되고, 오브젝트와 오브젝트간의 의존,연관 관계등에서 발생하는 이점을 활용하며 그 와중에 불가피하게 발생하는 문제점들을 해결하기위해 Design Pattern이라는 '베스트 프랙티스 해결법'을 수 많은 개발자들이 제시하고 있다.

세상에는 변하는것과 변하지 않는 것이 있다. 하지만 세상의 대부분은 변하게 되어있고 그 세상을 나타내는 오브젝트 또한 변하게 될 가능성이 아주 높다, 실 세상의 구현체가 변경되어지지 않는다고 하더라도 요구사항/비즈니스 프로세스/주변 환경 등 변화되어야만 할 원인은 너무나 많이 산재한다. 그리고 실제로도 그런 이유로 **오브젝트(클래스)는 많은 변화를 겪는다.**

하지만 변화가 일어날때마다 코드를 변경해야하는 수고를 해야한다면 개발자들은 똑같은 작업을 반복하다가 자발적으로 생각하지 못하는 원숭이 내지 기계가 되어버릴 것이다.

**"지혜로운 개발자는 오브젝트에서 발생할 수 있는 미래의 변화를 감지하고 설계하고, 개발해야한다"**

이렇게 하는것이 좋다는게 아니라 **해야만 한다**. 그래서 객체지향을 제대로 배워 현실 세계를 코드로 나타낸 가상의 오브젝트들이 자유롭고 편리하게 변경/발전/확장 될 수 있게 설계할 수 있도록 대비할 수 있게 노력해야한다.

그럼 오브젝트의 변화는 어떻게 대비할 수 있을까?

### 3. 분리와 확장

> 변화는 한번에 한 가지 관심에 집중되어 일어난다.

이 말인 즉슨, 요구사항의 변경으로 인한 오브젝트의 변화를 예로 들었을때 요구사항의 변경으로 인해

1. 사용중인 DB를 변경하면서
2. 웹 화면의 UI를 변경하고
3. 로그가 기록되는 날짜의 포맷을 yyyy-mm-dd 형태로 바꾸어라.

이런식으로 3개가 한꺼번에 변경되어지지는 않는다는 것이다.
DB를 변경한다면 DB 접속이나 관련 오브젝트들의 변화가 일어날것이고, 웹 화면의 UI를 변경해야 한다면 View 단,그리고 연관된 오브젝트들의 변화가 일어날것이다. 또 로그 날짜 포맷을 바꿔야 한다면 로그를 기록하는 파트의 오브젝트들만 변경될것이다.

즉 위 말은 변화는 이렇듯 한가지 관심에 집중되어서 일어난다는 것이다. 그렇기 때문에 관심사가 같은 것은 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른것은 가능 한 따로 떨어져 서로 영향을 주지않게끔 **분리**해야 한다.

그러기 위해서는 다양한 개발 방법론과 디자인 패턴들에 대해 익숙해야만 한다. 하지만 고맙게도 Spring은 이미 그런것들을 미리 구현해놓았고 사용하기 쉽게 우리에게 제공해주고있다. 그래서 Spring이 제공하는 코드 구조와 적절한 어노테이션 사용만으로도 고품질의 Web Application을 만들어낼 수 있다. 하지만 나는 내부 구조를 이해해야한다. 그래야 좋은 개발자가 될 수 있으니까

# DAO 이야기

Spring으로 CRUD를 구현을 여러번 하면서 DataSource를 수없이 사용해왔지만 그저 DB와의 연결을 주관하는 친구로 알고만 있었다. 이제는 이 친구가 왜 구현되었는지 알아야한다.

우선 DataSource는 Database에 접근하기위해 구현되어있는 PSA(Portable Service Abstraction) 이다. 여기에 나는 Tomcat에서 제공해주는 Tomcat jdbc conntection pool 이나 HicariCP 등의 구현체를 빈으로 생성할 수 있다. DataSource라는 인터페이스에다가 말이다.

Spring을 사용하기 이전, JDBC를 이용해 Java Application 에서 DB에 접속하는 방식을 모두가 사용해봤을 것이다. Spring 에서도 똑같이 JDBC Library를 사용해서 DB에 접속할 수 있다.

```java
public class JdbcDemo {
    public static void main(String[] args) {
        connectionDB();
    }

    public static void connectionDB() {
        Connection con = null;
        String user = "jaehyun";
        String password = "0111";
        String url = "jdbc:mysql://localhost:3306/jaehyunDB?&useSSL=false";
        try {
            Class.forName("com.mysql.jdbc.Driver");
            con = DriverManager.getConnection(url, user, password);
            System.out.println("database connection Success.!!");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if(con != null) con.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

작성도 금방 끝나고 작동도 정상이다. 근데 이건 좋지않은 코드다. 왜냐?  
application의 크기가 방대해 졌을때, 만약 이런 끔찍한 connectionDB()라는 메서드로 DB 커넥션을 접근하는 클래스로 DB 커넥션 기능을 구현하였다면 상상도 하기싫은 만큼 끔찍한 일이 벌어질 것이다.  
내부의 SQL문이 변경된다거나, url 혹은 Mysql에서 Oracle로 DB가 변경되는 코드 수정이 발생할 수도 있다. 근데 그 수정으로 인해 생긴 사이트 이펙트가 모든 클래스에 영향을 끼치게 될것이고 기능이 점점 추가되고 프로그램 크기가 커져갈때 곪아서 문제가 터져버릴것이다.

내가 공부하며 참고하고있는 토비의 스프링에서는 위의 코드를 점진적으로 리팩토링하는 과정을 그려나가고 있다. 내가 책을 쓸건 아니기 때문에 코드는 직접 적기엔 부담스럽다.. 원작자님의 저작권이기도 하고..

어쨋든 위 코드에서 관심사항을 분리하고, 테스트를 통해 변경사항에 대해 민감한지 검증한다. 그리고 상속을 통해 리팩토링된 클래스를 다시 리팩토링하고, 지속된 의존관계로 인해 인터페이스로 추상화를 도모한다. 그 과정에서 템플릿 메서드,팩토리 메서드 패턴 등 다양한 디자인 패턴도 사용되어진다.

코드상의 의존은 결국 main에서 발생할 수 밖에 없었다. 어쨋든 컴파일 시점에 인터페이스로 추상화된 객체가 레퍼런스할 오브젝트는 결국 생성되어져야 하기 때문이다. 이 의존을 해결할 수 있는 방법으로 Spring에서는 DI Container를 이용하여 IoC를 구현하고있다.

Spring에서는 레퍼런스할 오브젝트는 Bean의 형태로 Spring Container의 관리하에 들어가게 되고, 우리가 코드로 직접 제어하는것이 아니라 이제는 Spring Container가 이런 의존성을 관리함으로서 IoC를 실현하고 있었다.

Mybatis를 사용하지 않고 JDBC로 바로 DB가 연결된 웹을 개발할때 많이 작성했던 아래의 코드..

```java
@Repository
public class TestDaoImpl{
    @Autowired
    DataSource dataSource;
    // do some Thing..
}
```

이것은 ApplicationContext라는 Spring Container의 관리하에 xml파일에 기재한 나의 Datasource 설정 정보들을 읽어와 런타임 시점에서 DI를 행해주고 있는것이였다.

그렇기 때문에 만약 DataSource 인터페이스에 삽입될 DataSource의 구현 클래스가 SimpleDataSoruce가 되던, DriverManagerDataSource가 되던 여러개의 DAO 코드 변경없이 XML 파일의 변경 단 한번으로 변화를 이루어낼 수 있었던 것이었다. (물론 Configuration Annotaion을 이용하는 방법도 똑같다)

# ApplicationContext

스프링에서는 빈의 생성과 관계설정등 제어를 담당하는 IoC 담당 오브젝트를 Bean Factory라고 부른다. 이 BeanFactory가 더 확장된 구현체가 application Context이다. 이를 통해 애플리케이션 전반에 통틀어 모든 구성요소의 제어작업을 담당하는 IoC 컨테이너의 의미가 좀더 부각된다.  
**ApplicationContext는 SpringContainer라고 불린다.**

지금까지 애노테이션 혹은 Xml에 직접 기재하는 방식으로 Spring Container에게 Bean의 정보를 제공해주고 있었고 정보들을 이용해 Spring Container는 Bean을 제어하고 IoC를 주관하는 것이다. 이것이 가능한 이유는 Spring Container의 동작 방식에 있는데.. 동작방식은 아래와 같다.

![2021-01-02-1](/assets/2021-01-02-1.jpg)

# No 싱글톤 패턴, YES 싱글톤 레지스트리

자바에서 말하는 싱글톤 패턴의 일반적인 구현방법은 생성자를 private으로 하고, 전역 메서드를 통해 동일한 오브젝트 레퍼런스를 반환받을 수 있도록 구현되어진다. 하지만 이방법은 단점이있다.

- private 생성자를 가지기 때문에 상속이 불가능하다  
   : 객체지향적인 설계의 장점을 적용하기가 힘들다.
- 테스트하기가 힘들다  
   : 만들어지는 방식이 제한적이기 때문에
- 서버환경 에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다  
   : 클래스 로더를 어떻게 구성하고 있느냐에 따라 싱글톤이라도 하나 이상의 오브젝트가 만들어질 수 있다.여러개의 JVM에 분산되어 설치되는 경우에는 독립적으로 오브젝트가 생기기 때문에 이럴때에도 싱글톤으로의 가치가 떨어진다.
- 전역 상태를 이용하기 때문에 바람직 하지 못하다  
   : 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 애플리케이션 어디에서든 사용될 수가 있고 (멀티 쓰레딩 등) 아무객체나 수정,접근할 수 있는 전역 상태를 갖는다는것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.

Spring Container는 싱글턴 패턴이 아닌 싱글톤 레지스트리이다. 이 말인 즉슨 위와 같은 단점들이 존재하지 않고 public 생성자를 가질 수 이씅며, 테스트 환경에서 자유롭게 만들 수 있고 심지어는 목 오브젝트로 대체할 수 있다. 생성자에 접근가능 하기 때문에 파라미터를통해 사용할 오브젝트를 넣어주게 할 수 있는등 많은 장점이 있다.

즉, Spring에서의 빈은 싱글톤의 형태로 관리되어 지지만 이것은 Spring Contianer가 **싱글톤 레지스트리** 이기 때문에 가능한 것이다.

# 즉, Spring Container는 IoC(DI) 관리자이다

Spring의 IoC는 이 Spring Container라는 IoC를 주관하는 관리자가 담당하고 있으며, 싱글턴 레지스트리로 구성되어 싱글턴 패턴에서 발생할 수 있는 문제점들을 상당수 보완해냈다. 그리고 이런 IoC를 통한 객체지향적인 코드와 패턴을 적용시킬 수 있다는 것은 Spring의 아주 큰 장점이며 무기이다.
